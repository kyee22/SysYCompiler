<center><h1>《编译技术》课程实验总结感想</h1></center>




当我写下这篇感想的时候，也就完成了北航 6 系所谓计算机系统三件套“CPU、OS 和 Compiler”的全部打怪任务了……

>   是的，少年，~~你已经可以写出一个属于自己的计算机了！~~

>   哇！好厉害！真的吗？

下面是时候总结一下感想了。

## 一些收获

首先最直接的肯定还是关于编译本身的收获。

理解 CPU 最好的方式就是自己手搓一个 CPU，理解 OS 最好的方式就是自己手搓一个 OS，理解 Compiler 最好的方式就是自己手搓一个 Compiler！

我越发体会到计算机专业作为工科理论与实践相结合的重要性。在理论课上听再多，知识也只是停留在表层，只有自己动手 designing, coding, testing, debugging, testing, debugging, testing, debugging……在这样一个痛苦又快乐的过程中，才能有更深刻的领悟。

## 一些有趣的尝试

>   一些个人 **自认为** 有趣的尝试

除了编译器，不止编译器。

在学期初，我就打算把编译课程实验这样一个千行乃至万行代码的项目当作一个很好的锻炼机会，力求写出“好的代码”！

### 关于设计模式

在错误处理时，我实践了监听者模式；在语义分析、中间代码生成、目标代码生成时我都实践了访问者模式。

在 OO 课程中，为了图省事我都鲜少尝试设计模式，可是面对编译器这样的项目，我迫使自己尝试设计模式，也确实从中体会到设计模式历经无数实践凝练出的智慧结晶。

### 关于声明式编程

过去我了解到程序设计领域中的声明式编程、函数式编程，但我感觉从大一以来接受的训练接触到的都是面向过程编程、面向对象编程。甚至在 OO 课程上有把面向对象捧上神坛的意味。

在设计语法分析时，我利用函数式编程，采用声明式编程的方式编写语法解析规则，从而一个语法单元的解析只需要写一行代码，产生和 ANTLR4 类似的“半自动”效果。

按我之前那样面向对象的写法，我就需要极其繁琐地给每个语法单元写几十乃至上百行臃肿的代码。

经过这次实践，我在编程范式上切身体会到函数式编程的“经典”，面向对象编程也不是神话。采用什么样的范式也不应该成为教条。

### 关于测试

大二上“计组”的时候我还没有进行测试的意思，完全是面向评测机编程。

大二下“OO”的时候我自己有被迫或者主动尝试单元测试以及集成测试，但每周一次作业的强度还是太高，索性还是用大佬写的评测机算了。

这次，我一定要自己进行充分的测试。

能进行单元测试的就进行单元测试。比如词法分析。比如 Mem2Reg 的几个步骤前后勾连，每完成一个步骤就用已知教程中的 CFG 示例作为测试用例进行单元测试，来检验是否正确地进行了支配关系分析、是否正确地计算了支配边界。

集成测试时除了公共库，我还自己构建了本地的测试用例。

![image-20241219205016512](C:/Users/Arren/AppData/Roaming/Typora/typora-user-images/image-20241219205016512.png)

尤其是代码生成部分，我自己编写了 $20$ 多个测试用例，五花八门的测试程序都来自真实的 C 语言程序设计。

经过自己充分的本地测试及调试，我在递交到代码生成一、代码生成二、竞速排序的正式评测时都是一遍通过，这还是非常值得高兴的。

### 关于优化

学期前，我下定决心要做极致的优化，可是实践起来的优化效果并不那么令人满意。

而且就像某同学在[讨论区](https://judge.buaa.edu.cn/forum/thread.jsp?forum=811&thread=14414)提到的一样 ：

>   “这告诉我们，自己拍拍脑袋想出来的方法大概率是比不过经过漫长时间检验的工业级方法的。（）”

我感觉到优化的过程更多的是去机械地重复已有的成熟算法，给自己的自由度其实并不强，所以我后来也没有追求极致的优化了。

## 当我们在写编译器的时候，我们在写什么

编译器写完就完了吗？是应该还有一些 Take-away message！

之前写代码的时候我确实有很多 Take-away message，但最近都在突击数据库大作业半个月没看编译代码都忘了😭😭😭😭😭😭😭

于是想到哪写到哪……

如果说操作系统是计算机软硬件设计思想的集大成者，那编译器就是计算机软件设计思想的集大成者。在 ANTLR4、LLVM  这些足够现代的工具面前，我们的编译器显得微不足道。但在编译器实现中的分而治之、自顶向下、自底向上、迭代求解不动点等思想是可以带到编译本身之外的。

还有就是 debug 🐞的珍贵经历。每一次 debug 都是一场痛彻心扉的历程。每次 de 完之后惊讶地发现竟然还有这样的 bug。尤其是这学期我发现了一个最诡异 bug：

>   同样的编译程序竟然把同样的测试用例在 Windows 平台以及 Ubuntu 平台上翻译成不同的程序……！
>
>   难道我的代码竟然还写出来随机性会影响正确性的代码？我怎么也不相信！
>
>   历经数小时追根溯源我还发现真是……而且这个随机性造成的 bug 只有在极少数用例上显现。 

总之，“what doesn't kill you makes you stronger”。比起过段时间就会淡忘的那些——代码也好，理论也好——我相信，这些 debug 的经历会成为宝贵的财富。

## 一些建议

*   建议文法和测试公共库发布前做好充分的审查
*   建议前期作业就加强测试强度，避免前面的 bug 贯穿到后面（虽然暂时没有发生在我身上）
*   以及是否有必要让学生完全手动从零写语法分析程序
*   以及是否有必要让学生完全手动从零写 LLVM IR 生成的辅助程序